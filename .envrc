# .envrc (hardened)
export MAMBA_ROOT_PREFIX="$HOME/micromamba"
eval "$(micromamba shell hook -s bash)"

# Micromamba env lives in .venv (prefix mode)
VENVP="$PWD/.venv"

# If an old Python venv file exists, bail loudly to avoid mixing
if [[ -f "$VENVP/pyvenv.cfg" ]]; then
  echo "direnv: ERROR: $VENVP looks like a Python venv, not a micromamba env."
  echo "Remove or rename it, or choose a different prefix for micromamba."
  exit 1
fi

# Activate micromamba env if present
if [[ -d "$VENVP" ]]; then
  micromamba activate -p "$VENVP"
elif [[ -f "environment.yml" ]]; then
  echo "direnv: .venv not found; create it with:"
  echo "  micromamba create -y -p ./.venv -f environment.yml"
fi

# Load .env last, but DO NOT allow it to poison Python resolution
dotenv_if_exists

# Scrub problematic vars that break stdlib resolution
unset PYTHONHOME
unset PYTHONPATH
export PYTHONNOUSERSITE=1

# Sanity assertions (visible in `direnv log`)
command -v python >/dev/null && \
  echo "direnv: using $(command -v python)"
python - <<'PY' 2>/dev/null || true
import sys, importlib.util as u, os
print("direnv: sys.executable=", sys.executable)
print("direnv: lib-dynload in sys.path?", any(os.path.basename(p)=="lib-dynload" for p in sys.path))
print("direnv: _posixsubprocess spec:", u.find_spec("_posixsubprocess"))
print("direnv: math spec:", u.find_spec("math"))
PY


